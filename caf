#!/usr/bin/env python3
"""caf -- Calculation framework.

Usage:
    caf init
    caf [init] build [--dry]
    caf [[init] build] work [TARGET... | --brewery] [--depth N] [--limit N]
                            [--profile PROFILE [-j N] | [--id ID] [--dry]]
    caf submit URL [TARGET...]
    caf submit URL TASK... --task
    caf work [--queue URL] [--profile PROFILE [-j N] | [--id ID] [--dry]]
    caf status
    caf reset [TARGET...]
    caf list (profiles | remotes)
    caf list tasks [--finished | --stored]
    caf search [--contains PATTERN] [--older TIME]
    caf cmd CMD
    caf cmd CMD [TARGET...] --task [--print]
    caf remote add URL [NAME]
    caf update REMOTE [--delete]
    caf check REMOTE [TARGET...]
    caf push REMOTE [TARGET...] [--dry]
    caf fetch REMOTE [TARGET...] [--dry]
    caf fetch REMOTE [TASK...] --task [--dry]
    caf go REMOTE
    caf REMOTE [--no-check] [--] CMD...
    caf (pack | unpack | strip)

Options:
    -n, --dry                  Dry run (do not write to disk).
    --id ID                    ID of worker [default: 1].
    -p, --profile PROFILE      Run worker via ~/.config/caf/worker_PROFILE.
    -q, --queue URL            Take tasks from web queue.
    -j N                       Number of launched workers [default: 1].
    -d, --depth N              Limit depth of descending to children.
    -l, --limit N              Limit number of tasks to N.
    -t, --task                 Change command's context to tasks.
    --print                    Print path to task before running a command.
    --brewery                  Work on tasks in Brewery.
    --finished                 List finished tasks.
    --delete                   Delete files when syncing.
    --stored                   List stored tasks.
    --contains PATTERN         Search tasks containing PATTERN.
    --older TIME               Search tasks older than.
    -0, --no-check             Do note check remote Cellar.

Commands:
    init
        Initialize the caf repository in ./_caf. If 'cache' is defined in
        ~/.config/caf/conf.yaml, the repository is created there and symlinked
        to ./_caf, otherwise it is created locally.

    build
        Prepare build tasks and targets defined in ./cscript. Tasks are created
        in ./_caf/Brewery/Latest and if their preparation does not depened on
        unfinished tasks, they are prepared and stored in ./_caf/Cellar based
        on their SHA1 hash. Targets (collections of symlinks to tasks) are
        created in ./build/Latest.

    work
        Execute all prepared build tasks.

    submit
        Submit the list of prepared tasks to a queue server.

    status
        Print number of initialized, running and finished tasks.

    reset
        Remove working lock on tasks.

    list
        Print various diagnostics.

    search
        Search within stored tasks.

    cmd
        Execute any shell command after sourceing ~/.bashrc. This is a simple
        convenience alias for running commands remotely.

    remote
        add
            Define a new remote and save it in ./.caf/remotes.yaml.

    update
        Sync the contents of . to remote excluding ./_caf and ./build.

    check
        Verify that hashes of the local and remote tasks match.

    push
        Push targets to remote and store them in remote Cellar.

    fetch
        Fetch targets from remote and store them in local Cellar.

    go
        SSH into the remote caf repository.

    REMOTE
        Run './caf CMD' in remote caf repository. See `Remotes` below.

    pack, unpack, strip
        This controls the packing of the caflib directory into the caf script.

Remotes:
    For all commands except `go`, REMOTE can be a single remote name, a
    comma-separated list of remotes or "all" which is an alias for all remotes
    defined in .caf/remotes.yaml.
"""
from docopt import docopt
from itertools import takewhile
from pathlib import Path
import os
import sys
import subprocess
import shutil
from hashlib import md5
import signal

out = Path('build')
cache = Path('_caf')
cellar = 'Cellar'
brewery = 'Brewery'
latest = 'Latest'


def load_cscript():
    from caflib.Logging import error
    import imp
    cscript = imp.new_module('cscript')
    try:
        exec(compile(open('cscript').read(), 'cscript', 'exec'), cscript.__dict__)
    except:
        import traceback
        traceback.print_exc()
        error('There was an error while reading cscript.')
    return cscript


def pack():
    from base64 import b64encode
    archive = subprocess.check_output(
        'find caflib -type f ! -name "*.pyc" | xargs tar -cz', shell=True)
    with open('caf', 'a') as f:
        f.write('# ==>\n')
        f.write('# {}\n'.format(b64encode(archive).decode()))
        f.write('# <==\n')


def unpack(path):
    from base64 import b64decode
    with open('caf') as f:
        lines = f.readlines()
    if '# ==>' not in lines[-3]:
        print('Has no packed caflib, quitting')
        sys.exit()
    archive = b64decode(lines[-2][2:])
    p = subprocess.Popen('mkdir -p {0} && tar -C {0} -xz'.format(path),
                         shell=True,
                         stdin=subprocess.PIPE)
    p.communicate(input=archive)


def strip():
    with open('caf') as f:
        lines = takewhile(lambda l: l != '# ==>\n', f.readlines())
    with open('caf', 'w') as f:
        for line in lines:
            f.write(line)


def packing():
    if len(sys.argv) > 1:
        if sys.argv[1] == 'pack':
            strip()
            pack()
            sys.exit()
        if sys.argv[1] == 'unpack':
            if Path('caflib').is_dir():
                shutil.rmtree('caflib')
            unpack('.')
            sys.exit()
        if sys.argv[1] == 'strip':
            strip()
    if not Path('caflib').is_dir():
        with open('caf') as f:
            lines = f.readlines()
        if '# ==>' not in lines[-3]:
            print('No caflib and none packaged, quitting')
            sys.exit()
        dirname = '.caf-{}'.format(md5(lines[-2].encode()).hexdigest())
        if not Path(dirname).is_dir():
            unpack(dirname)
        sys.path.insert(0, dirname)


def finalize(sig, frame):
    print_timing()
    sys.exit()


if __name__ == '__main__':
    packing()
    signal.signal(signal.SIGINT, finalize)

    from caflib.Utils import Configuration, mkdir, get_timestamp, filter_cmd, \
        get_files, print_timing, timing, relink, cd
    from caflib.Logging import error, info, colstr, Table, log_caf
    from caflib.Context import get_stored

    remote_conf = Configuration('.caf/remotes.yaml')
    if len(sys.argv) > 1:
        if (any(r in remote_conf for r in sys.argv[1].split(',')) or
                sys.argv[1] == 'all'):
            i = next(i+2 for i, arg in enumerate(sys.argv[2:]) if arg[0] != '-')
            if sys.argv[i-1] != '--':
                sys.argv.insert(i, '--')  # fix cmd arguments for ./caf REMOTE
    args = docopt(__doc__)
    if args['REMOTE'] and args['CMD']:
        remote_args = docopt(__doc__, argv=args['CMD'])
        if remote_args['REMOTE']:
            docopt(__doc__, argv=['./caf'])
    log_caf(sys.argv)
    if args['REMOTE']:
        from caflib.Remote import Remote
        if args['REMOTE'] == 'all':
            remotes = remote_conf.keys()
        else:
            remotes = args['REMOTE'].split(',')
        try:
            remotes = [Remote(**remote_conf[r]) for r in remotes]
        except KeyError as e:
            error('Remote "{}" is not defined'.format(e.args[0]))
    else:
        remotes = []
    with timing('reading cscript'):
        cscript = load_cscript()
    if hasattr(cscript, 'out'):
        out = Path(cscript.out)
    if hasattr(cscript, 'cache'):
        cache = Path(cscript.cache)
    if args['init']:
        conf = Configuration(os.environ['HOME'] + '/.config/caf/conf.yaml')
        if 'cache' in conf:
            timestamp = get_timestamp()
            cache_path = Path(conf['cache'])/'{}_{}'.format(Path().resolve().name, timestamp)
            mkdir(cache_path)
            relink(cache_path, cache)
        else:
            info('Global cache not found in ~/.config/caf/conf.yaml, using a local one.')
            mkdir(cache)
        mkdir(cache/cellar)
        mkdir(cache/brewery)
    if args['build']:
        from caflib.Context import Context
        from caflib.Utils import mkdir, get_timestamp
        ctx = Context(cache/cellar)
        with timing('dependency tree'):
            cscript.build(ctx)
        if not args['--dry']:
            timestamp = get_timestamp()
            mkdir(cache/brewery/timestamp)
            relink(timestamp, cache/brewery/latest)
            mkdir(out/timestamp, parents=True)
            relink(timestamp, out/latest)
            with timing('build'):
                ctx.build(cache/brewery/latest)
            with timing('targets'):
                ctx.make_targets(out/latest)
    if args['work']:
        if args['--profile']:
            for _ in range(int(args['-j'])):
                cmd = ['{}/.config/caf/worker_{}'
                       .format(os.environ['HOME'], args['--profile']),
                       args['TARGET'],
                       ('-d', args['--depth']),
                       ('-l', args['--limit']),
                       ('-q', args['--queue']),
                       args['--brewery']]
                try:
                    subprocess.check_call(filter_cmd(cmd))
                except subprocess.CalledProcessError:
                    error('Running ~/.config/caf/worker_{} did not succeed.'
                          .format(args['--profile']))
        else:
            from caflib.Worker import Worker
            if args['--brewery']:
                path = (cache/brewery/latest).resolve()
                args['--depth'] = 1
            else:
                path = (out/latest).resolve()
            worker = Worker(args['--id'], path)
            if args['--queue']:
                worker.work_from_queue(
                    (cache/cellar).resolve(),
                    args['--queue'],
                    dry=args['--dry'],
                    limit=int(args['--limit']) if args['--limit'] else None)
            else:
                worker.work(
                    args['TARGET'],
                    dry=args['--dry'],
                    maxdepth=int(args['--depth']) if args['--depth'] else None,
                    limit=int(args['--limit']) if args['--limit'] else None)
    elif args['submit']:
        from urllib.request import urlopen
        if args['--task']:
            hashes = [get_stored(task, rel=True) for task in args['TASK']]
        else:
            if args['TARGET']:
                hashes = [get_stored(path, rel=True)
                          for path in subprocess.check_output([
                              'find', '-H', str(out/latest), '-type', 'l'])
                          .decode().split()]
            else:
                hashes = [get_stored(path, rel=True)
                          for path in (cache/brewery/latest).glob('*')
                          if path.is_symlink()]
        with urlopen(args['URL'], data='\n'.join(hashes).encode()) as r:
            print('./caf work --queue {}'.format(r.read().decode()))
    elif args['reset']:
        if args['TARGET']:
            paths = map(Path, subprocess.check_output([
                'find', '-H', str(out/latest), '-type', 'l'])
                .decode().split())
        else:
            paths = [p for p in (cache/brewery/latest).glob('*') if p.is_symlink()]
        for p in paths:
            if (p/'.lock').is_dir():
                (p/'.lock').rmdir()
    elif args['list']:
        if args['profiles']:
            for p in Path(os.environ['HOME']).glob('.config/caf/worker_*'):
                print(p.name)
        elif args['remotes']:
            print(remote_conf)
        elif args['tasks']:
            if args['--finished']:
                subprocess.call(['find', '-H', str(out/latest), '-exec',
                                 'test', '-f', '{}/.caf/seal', ';', '-print'])
            elif args['--stored']:
                files = get_files(out/latest)
                for task, target in files:
                    ptarget = Path(target)
                    if ptarget.parents[2].name == cellar:
                        print(task, Path('/'.join(ptarget.parts[-4:])))
            else:
                files = get_files(out/latest)
                for task, target in files:
                    ptarget = Path(target)
                    print(task, Path('/'.join(ptarget.parts[-4:])))
    elif args['search']:
        cmd = ['find', str(cache/cellar), '-maxdepth', '3',
               '-mindepth', '3', '-type', 'd']
        if args['--older']:
            lim = args['--older']
            if lim[0] not in ['-', '+']:
                lim = '+' + lim
            cmd.extend(['-ctime', lim])
        if args['--contains']:
            cmd.extend(['-exec', 'test', '-f',
                        '{{}}/{}'.format(args['--contains']), ';'])
        cmd.append('-print')
        subprocess.call(cmd)
    elif args['status']:
        def colored(stat):
            colors = 'red green yellow normal'.split()
            return [colstr(s, color) for s, color in zip(stat, colors)]

        dirs = []
        dirs.append((cache/brewery/latest, (cache/brewery/latest).glob('*')))
        for target in (out/latest).glob('*'):
            if not target.is_dir() or str(target).startswith('.'):
                continue
            if target.is_symlink():
                dirs.append((target, [target]))
            else:
                dirs.append((target, target.glob('*')))
        print('number of {} tasks:'
              .format('/'.join(colored('running finished prepared all'.split()))))
        table = Table(align=['<', *4*['>']], sep=[' ', *3*['/']])
        for directory, paths in sorted(dirs):
            stats = []
            locked = []
            for p in paths:
                stats.append(((p/'.lock').is_dir(), (p/'.caf/seal').is_file(),
                              (p/'.caf/lock').is_file(), (p/'.caf').is_dir()))
                if (p/'.lock').is_dir():
                    locked.append(p)
            stats = colored([len(list(filter(lambda x: x, stat))) for stat in zip(*stats)])
            table.add_row(str(directory) + ':', *stats)
            if directory.parts[1] != 'Brewery':
                for path in locked:
                    table.add_row('{} {}'.format(colstr('>>', 'blue'), path), free=True)
        print(table)
    elif args['cmd']:
        if args['--task']:
            if args['TARGET']:
                paths = map(Path, subprocess.check_output([
                    'find', '-H', str(out/latest), '-type', 'l'])
                    .decode().split())
            else:
                paths = [p for p in (cache/brewery/latest).glob('*') if p.is_symlink()]
            for path in paths:
                if args['--print']:
                    info('Running `{}` in {}'.format(args['CMD'][0], path))
                with cd(path):
                    subprocess.call(args['CMD'][0], shell=True)
        else:
            subprocess.call(args['CMD'][0], shell=True)
    elif args['remote']:
        if args['add']:
            conf = Configuration('.caf/remotes.yaml')
            host, path = args['URL'].split(':')
            name = args['NAME'] or host
            conf[name] = {'host': host, 'path': path}
            conf.save()
    elif args['update']:
        for remote in remotes:
            remote.update(delete=args['--delete'])
    elif args['check']:
        for remote in remotes:
            remote.check(args['TARGET'], out/latest)
    elif args['push']:
        for remote in remotes:
            remote.push(args['TARGET'], cache/cellar, out/latest, args['--dry'])
    elif args['fetch']:
        for remote in remotes:
            if args['--task']:
                remote.fetch(cache/cellar, tasks=args['TASK'], dry=args['--dry'])
            else:
                remote.fetch(cache/cellar, batch=out/latest,
                             targets=args['TARGET'], dry=args['--dry'])
    elif args['go']:
        for remote in remotes:
            remote.go()
    elif remotes:
        if args['CMD'][0] in ['init', 'build', 'work']:
            for remote in remotes:
                remote.update()
        if not args['--no-check'] and 'work' in args['CMD'] \
                and 'build' not in args['CMD']:
            for remote in remotes:
                remote.check(args['TARGET'], out/latest)
        if args['CMD'][0] == 'cmd':
            args['CMD'][1] = repr(args['CMD'][1])
        for remote in remotes:
            remote.command(' '.join(args['CMD']))
            if not args['--no-check'] and 'work' in args['CMD'] \
                    and 'build' in args['CMD']:
                remote.check(args['TARGET'], out/latest)
    print_timing()
