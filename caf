#!/usr/bin/env python3
"""caf -- Calculation framework.

Usage:
    caf init
    caf build
    caf work [TARGET...] [-0] [-p PROFILE [-j N] | [--id ID] [-n]]
    caf status
    caf remote add URL [NAME]
    caf update REMOTE
    caf push REMOTE [TARGET...] [-n]
    caf fetch REMOTE [TARGET...] [-n]
    caf run REMOTE [--] CMD...
    caf go REMOTE

Options:
    -p, --profile PROFILE      Run worker via ~/.config/caf/worker_PROFILE.
    -j N                       Number of launched workers [default: 1].
    --id ID                    ID of worker [default: 1].
    -n, --dry                  Dry run.
    -0                         Do not descend into dependencies.

Commands:
    init
        Initialize the caf repository in ./_caf. If 'cache' is defined in
        ~/.config/caf/conf.yaml, the repository is created there and symlinked
        to ./_caf, otherwise it is created locally.

    build
        Prepare build tasks and targets defined in ./cscript. Tasks are
        prepared in ./_caf/Brewery/Latest and if their preparation does not
        depened on unfinished tasks, they are stored in ./_caf/Cellar based on
        their SHA1 hash. Targets (collections of symlinks to tasks) are created
        in ./build/Latest.

    work
        Execute all prepared build tasks.

    status
        Print number of initialized, running and finished tasks.

    remote
        add
            Define a new remote and save it in ./.caf/remotes.yaml.

    update
        Sync the contents of . to remote excluding ./_caf and ./build.

    push
        Push targets to remote and store them in remote Cellar.

    fetch
        Fetch targets from remote and store them in local Cellar.

    run
        Run './caf CMD' in remote caf repository.

    go
        SSH into the remote caf repository.
"""
from docopt import docopt
from pathlib import Path
import os
import sys

from caflib.Utils import Configuration, mkdir, get_timestamp
from caflib.Logging import error, info

out = Path('build')
cache = Path('_caf')
cellar = 'Cellar'
brewery = 'Brewery'
latest = 'Latest'


def load_cscript():
    import imp
    cscript = imp.new_module('cscript')
    try:
        exec(compile(open('cscript').read(), 'cscript', 'exec'), cscript.__dict__)
    except:
        import traceback
        traceback.print_exc()
        error('There was an error while reading cscript.')
    return cscript


def make_new_build():
    timestamp = get_timestamp()
    mkdir(cache/brewery/timestamp)
    os.system('ln -fns {} {}'.format(timestamp, cache/brewery/latest))
    mkdir(out/timestamp, parents=True)
    os.system('ln -fns {} {}'.format(timestamp, out/latest))


def report(path, *paths):
    print('{}: number of initialized/running/finished tasks: {}/{}/{}'
          .format(path,
                  len([p for p in paths if (p/'.caf').is_dir()]),
                  len([p for p in paths if (p/'.lock').is_dir()]),
                  len([p for p in paths if (p/'.caf/seal').is_file()])))


if __name__ == '__main__':
    if sys.argv[1] == 'run' and sys.argv[3] != '--':
        sys.argv.insert(3, '--')
    args = docopt(__doc__)
    if args['REMOTE']:
        from caflib.Remote import Remote
        remote_conf = Configuration('.caf/remotes.yaml')
        remote = args['REMOTE']
        try:
            remote = Remote(**remote_conf[remote])
        except KeyError:
            error('Remote {!r} is not defined'.format(remote))
    if args['init']:
        conf = Configuration(os.environ['HOME'] + '/.config/caf/conf.yaml')
        if conf['cache']:
            timestamp = get_timestamp()
            cache_path = Path(conf['cache'])/'{}_{}'.format(Path().resolve().name, timestamp)
            mkdir(cache_path)
            os.system('ln -fns {} {}'.format(cache_path, cache))
        else:
            info('Global cache not found in ~/.config/caf/conf.yaml, using a local one.')
            mkdir(cache)
        mkdir(cache/cellar)
        mkdir(cache/brewery)
    elif args['build']:
        from caflib.Context import Context
        cscript = load_cscript()
        ctx = Context(cache/cellar)
        cscript.build(ctx)
        make_new_build()
        ctx.build(cache/brewery/latest)
        ctx.make_targets(out/latest)
    elif args['work']:
        if args['--profile']:
            import subprocess
            for _ in range(int(args['-j'])):
                try:
                    subprocess.check_call('~/.config/caf/worker_{} {}'
                                          .format(args['--profile'],
                                                  ' '.join(args['TARGET'])) +
                                          (' -0' if args['-0'] else ''),
                                          shell=True)
                except subprocess.CalledProcessError:
                    error('Running ~/.config/caf/worker_{} did not succeed.'
                          .format(args['--profile']))
        else:
            from caflib.Worker import Worker
            worker = Worker(args['--id'], out/latest)
            worker.work(args['TARGET'], dry=args['--dry'], descend=not args['-0'])
    elif args['status']:
        import glob
        report(cache/brewery/latest, *(cache/brewery/latest).glob('*'))
        for target in glob.glob(str(out/latest) + '/*'):
            target = Path(target)
            if not target.is_dir():
                continue
            if target.is_symlink():
                report(target, target)
            else:
                report(target, *target.glob('*'))
    elif args['remote']:
        if args['add']:
            conf = Configuration('.caf/remotes.yaml')
            host, path = args['URL'].split(':')
            name = args['NAME'] or host
            conf[name] = {'host': host, 'path': path}
            conf.save()
    elif args['update']:
        remote.update()
    elif args['push']:
        remote.push(args['TARGET'], cache/cellar, out/latest, args['--dry'])
    elif args['fetch']:
        remote.fetch(args['TARGET'], cache/cellar, out/latest, args['--dry'])
    elif args['run']:
        if args['CMD'][0] in ['init', 'build', 'work']:
            remote.update()
        remote.command(' '.join(args['CMD']))
    elif args['go']:
        remote.go()
